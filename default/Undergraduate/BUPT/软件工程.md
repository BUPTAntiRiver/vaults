# 1 软件工程基本概念总结

## 1.1 软件的定义

IEEE 定义软件是计算机程序、规程、运行系统所需文档和数据的集合；Wirth 提出软件工程中软件 = 程序 + 文档；公认解释为软件是程序、数据及其相关文档的完整集合，其中程序和数据是基础，文档是质量与生命周期保障。

## 1.2 软件工程的起源：软件危机的时代背景

20 世纪 60 年代后，软件应用领域扩大，规模增长，功能和逻辑愈发复杂。但当时软件开发方法与技术不成熟，导致一系列严重问题，进而引发软件危机，成为软件工程诞生的直接动因。

## 1.3 软件工程的诞生

软件危机的核心问题是软件开发与维护过程中存在的效率、质量、成本等失控现象，具体表现为成本难以估算、需求表达不明确、质量不达标、可维护性差、缺乏文档等。1968 年，Friedrich Ludwig（Fritz）Bauer 提出运用工程化原则和方法组织软件开发，以解决软件危机，“软件工程” 概念正式诞生。

## 1.4 软件工程的定义

- Bauer（1968 年）：为经济地获得能在实际机器上高效运行的可靠软件，而建立和使用的一系列好的工程化原则。

- IEEE：一是应用系统化、规范化、定量的方法开发、运行和维护软件（将工程应用到软件）；二是对上述方法的研究。

- 文档中未提及 Boehm、Fairley 的相关定义。

## 1.5 软件工程的三要素、目标和原则

### 三要素

- 方法：提供 “如何做” 的技术支撑。

- 工具：提供自动或半自动的软件支撑环境。

- 过程：整合方法与工具，保障软件开发合理、及时推进。

### 目标

生产具有正确性、可用性且开销适宜的软件产品，软件需具备可修改性、有效性、可靠性等 10 项性质，最终摆脱手工生产模式，实现软件研制和维护自动化。

### 原则

- 核心原则：选取适宜的开发模型、采用合适的设计方法、提供高质量工程支持、重视开发过程管理。

- 一般原理：包含抽象、信息隐藏、模块化等 8 方面。

- 基本原理：涵盖分阶段生命周期计划管理、阶段评审等 7 条。

## 1.6 软件工程学科研究的内容

- 软件开发技术：包括软件开发方法学、开发过程模型、开发工具、软件工程环境等。

- 软件工程管理：涵盖软件管理学、软件工程经济学、软件心理学等。

# 2 软件生命周期模型总结

## 2.1 工程项目质量的三个目标

工程项目的核心质量目标包括三点，分别是合理的进度（时间维度）、有限的经费（成本维度）和符合客户需求的质量（成果维度），三者共同构成项目成功的关键要素。

## 2.2 质量目标的实现方法：PDCA 循环

为达成质量目标，需遵循戴明博士提出的 PDCA 循环，即计划（Plan）、执行（Do）、检查（Check）、改进（Action）四个环节，形成闭环管理以持续优化项目质量。

## 2.3 软件工程的核心执行活动

软件工程需执行四项关键活动，分别是软件规格说明（明确功能与使用限制）、软件开发（生成符合规格的产品）、软件确认（验证是否满足客户要求）、软件演进（根据变更需求持续改进）。

## 2.4 软件生命周期的定义及模型

软件生命周期指软件从概念提出到停止使用的整个时期，核心包含六个基本活动，对应具体工件与操作：

1. 制定开发计划（确定目标、可行性分析、资源与进度规划）；

2. 需求分析（明确用户要求，编写需求规格说明书）；

3. 软件设计（含概要设计与详细设计，形成设计说明书）；

4. 编码（将设计转化为计算机可识别的程序代码）；

5. 测试（通过单元、组装、有效性测试验证软件合格性）；

6. 部署运行（交付后执行改正性、适应性、完善性维护）。

软件生命周期模型是涵盖上述全流程的框架，明确了各阶段的活动、工件与参与角色。

## 2.5 传统软件生命周期模型

传统模型以 1970 年提出的瀑布模型为基础，经十余年发展形成多种变种，均包含六个基本活动，仅在执行逻辑与结构上存在差异，且各有适配场景：

- 瀑布模型：线性顺序执行，文档驱动，适用于需求明确、规模较小的项目，优点是过程透明可管理，缺点是灵活性差、风险控制弱；

- 演化模型：分两次开发（试验原型探索需求 + 正式开发），适用于需求模糊的中小型短周期项目，优点是明确需求、降低风险，缺点是难管理、结构较差；

- 增量模型：按优先级分步开发核心功能，逐步集成完整系统，优点是客户早用核心功能、风险低，缺点是增量粒度难选择；

- 喷泉模型：各阶段重叠并行，迭代推进，优点是效率高、周期短，缺点是管理难度大；

- 螺旋模型：以风险分析为核心，分制定计划、风险分析、实施工程、客户评价四象限，适用于大型高风险项目；

- 其他模型：V 模型（提前测试活动）、W 模型（V 模型扩展）、构件组装模型（复用构件高效开发）、快速应用开发模型（短周期增量开发，适配管理信息系统）。

## 2.6 原型方法

原型方法并非独立生命周期模型，而是可应用于各类模型不同阶段的辅助方法，核心解决三类问题：需求不明确、技术路线选择、具体算法确认。

- 核心逻辑：获取基本需求后快速构建小型原型，用户通过使用反馈修改意见，优化需求与设计；

- 种类：探索型（明确需求与可行性）、实验型（验证技术与设计规格）、进化型（适应需求变化，逐步进化为最终系统）；

- 适用场景：需求变动频繁、中小型项目，不适用于大型系统或逻辑运算密集的模块。

## 2.7 现代软件生命周期模型

现代模型聚焦面向对象分析设计与多变需求，核心代表为 UP 模型与极限编程（XP）模型：

### UP 模型（Rational Unified Process）

- 基本结构：以用例为驱动、软件体系结构为核心，采用迭代增量模式；

- 四个阶段：初始阶段（明确项目边界与愿景）、细化阶段（建立体系结构、解决高风险需求）、构造阶段（开发集成剩余功能并测试）、交付阶段（确保软件对用户可用），各阶段以里程碑结束并需评审；

- 核心活动：含 6 个核心过程工作流（业务建模、需求、分析设计、实现、测试、部署）与 3 个支持工作流（配置变更管理、项目管理、环境），所有活动均需多次迭代完成。

### 极限编程（XP）模型

- 核心特点：轻量级方法，快速响应需求变化，强调用户满意；

- 需求管理：将需求转化为 “用户故事（User Story）”，客户指定优先级与验收测试，开发人员评估风险并制定计划；

- 开发计划：基于用户故事与优先级，结合项目速度制定迭代计划与发布计划；

- 核心操作：

1. 设计：采用测试驱动开发（TDD），重视设计复核、代码复核与重构；

2. 编程：推行配对编程、集体代码所有权，严格遵守编程规范；

3. 测试：先写单元测试，持续集成并频繁运行测试，包含单元测试、整合测试、功能测试等多类测试；

- 与瀑布模型的区别：摒弃线性顺序，采用需求、设计、开发的多重循环迭代，强调快速反馈与灵活调整，弱化文档依赖。

# 3 软件需求分析总结

## 3.1 需求的定义和来源

- 定义：需求源于用户的 “需要”，经分析确认后形成完整文档，明确产品 “必须或应当” 做什么；Boehm 认为需求是需用无二义性工具，为用户与软件人员共同接受并严格形式化表达的内容。

- 来源：核心来自用户（软件使用者）和客户（软件购买者），同时需结合产品发展战略、技术可行性等因素综合确定。

## 3.2 需求的多变性以及需求分析的必要性

- 需求多变性：用户初期难以清晰表达需求，对需求的理解易存在偏差，且在项目推进中可能产生新需求，导致需求频繁变更。

- 分析必要性：需求分析是连接系统分析与软件设计的桥梁，能明确软件功能、性能、接口及约束条件，构建分析模型并形成需求文档，为设计、测试提供依据，避免因需求模糊或偏差导致软件质量问题。

## 3.3 需求分析活动的结果

1. 用户需求说明书：本质是调研报告，以自然语言表达用户需求，内容较粗略，记录用户的核心诉求与使用场景，需经用户和专家评审确认。

2. 软件需求规格说明书：是用户需求说明书的细化，结合计算机语言和图形符号刻画需求，是软件设计、开发的直接依据，需开发方与客户方共同确认。

## 3.4 需求分析模型的三个维度

- 功能模型：描述软件对输入信息和数据的变换处理，核心包含输入、处理、输出三个基本功能。

- 数据模型：刻画信息内容、数据关系、信息流及信息结构，明确软件处理的数据基础。

- 行为模型：基于软件对外部事件的刺激 - 反应特征，构建软件状态及导致状态变化的事件表示。

## 3.5 需求分析的目标、对象和任务

### 核心概念界定

- 当前系统：近似无软件支持的纯业务系统，是分析的基础参考。

- 目标系统：待构建的软件系统，是需求分析的最终指向。

- 逻辑模型（What）：描述系统 “做什么”，明确功能与数据关系，不涉及实现细节。

- 物理模型（How）：描述系统 “如何做”，体现处理功能和数据结构的实际表示形式，常受设备约束。

### 具体内容

- 目标：借助当前系统的逻辑模型导出目标系统的逻辑模型，解决目标系统 “做什么” 的问题。

- 对象：用户提出的各类需求，包括功能、性能、环境等方面的要求。

- 任务：准确定义新系统的目标，明确系统 “做什么”，并编制规范的需求规格说明书。

## 3.6 需求工程

需求工程是与需求直接相关的一系列软件工程活动，核心分为两大模块：

- 需求开发：包含需求获取、需求分析、需求定义、需求确认等环节，最终产出用户需求说明书和软件需求规格说明书。

- 需求管理：涵盖需求变更控制、需求跟踪等活动，确保需求在项目全生命周期中被有效管控，适配需求的多变性。

# 4 面向对象需求分析建模方法总结

## 4.1 UML 核心基础

### 定义及发展历程

UML（统一建模语言）是面向对象分析与设计的标准可视化建模语言，由 Grady Booch、Ivar Jacobson 和 James Rumbaugh 发起，基于 Booch、OMT 和 OOSE 方法整合而成。其发展历经 “各自为政”（1980s-1993）、统一阶段（1994-1996）、标准化阶段（1997 年 OMG 采纳 UML1.1 为标准）、工业界应用（1998 年后成为事实标准）四个阶段。

### 结构事物、行为事物及关系

- 结构事物：描述系统静态结构，包括类、接口、协作、用例、构件、节点、包、注释等。

- 行为事物：描述系统动态行为，包括交互、状态机等。

- 事物关系：包含依赖（松散关联，如方法参数引用）、关联（对象间长期联系）、泛化（继承关系）、实现（类与接口的契约关系）四类。

## 4.2 UML 4+1 视图与开发模式

### 4+1 视图

- 用例视图：从用户角度描述系统功能，也称用户模型视图，关联用例图和活动图。那个1。

- 逻辑视图：展现系统静态结构与特征，关联类图、对象图、顺序图 / 协作图。

- 进程视图：描述并发、同步等特性，关注非功能性需求，关联状态图和活动图。

- 构件视图：关注代码静态组织，也称开发视图，关联构件图。

- 部署视图：描述软硬件拓扑与映射，也称物理视图，关联部署图。

### 开发模式

采用**用例驱动**模式，以用例为核心串联需求分析、设计、开发全流程，确保系统功能与用户需求一致。

## 4.3 UML 9 个基本图形元素（核心聚焦）

UML 包含 9 类基本图，核心需掌握以下 4 类：

- 用例图：描述角色与系统功能的关系，明确 “谁用系统做什么”。

- 类图：描述类及类间关系，展现系统静态数据结构。

- 时序图（顺序图）：按时间顺序描述角色与系统、系统内部对象的交互过程。

- 活动图：描述业务流程或对象行为的步骤序列，展现动态执行逻辑。

其余 5 类为对象图、协作图、状态图、构件图、部署图，分别适配不同建模场景。

## 4.4 领域模型（当前系统的模型表达）

### 核心定位

领域模型是当前系统（无软件的业务系统）物理模型与逻辑模型的总称，可简化为逻辑模型（基于物理模型理解推导），是软件后台服务设计的直接参考。

### 业务流程（物理模型）

- 核心是记录业务操作具体细节，需先通过文字调研记录流程，再用 UML 活动图可视化表示（含角色、活动节点、数据对象、消息流转）。

### 业务背景（逻辑模型）

- 提取调研报告中的名词作为概念类（Real world Class），区分类名称（不可赋值）与类属性（可具体赋值，如数字、文本）。

- 建立概念类间的关联关系，用 UML 类图表示。

- 概念类与软件类直接相关：软件类的名称、职责多源于领域模型的概念类，减少思维与软件模型的表示差异。

## 4.5 UML 类间关系（含代码映射与设计影响）

类间关系按紧密程度从低到高排列，需规范使用图形符号，且与 OO 代码直接对应，影响软件耦合度、内聚性及设计原则：

- 依赖关系：类 A 通过方法参数、局部变量或静态方法使用类 B，代码中体现为局部引用或静态调用。

- 关联关系：对象间长期联系，分双向（双方持有引用）和单向（仅一方持有引用），代码中体现为成员变量引用。

- 聚合关系：整体与部分可分离（如学校与老师），代码中整体类持有部分类的引用，部分类可独立存在。

- 组合关系：整体与部分不可分离（如文档与章节），代码中整体类创建并管理部分类，部分类随整体销毁。

- 继承关系：子类继承父类属性与方法，代码中通过继承语法实现（如 Java 的 extends）。

- 实现关系：类实现接口的契约，代码中通过实现语法实现（如 Java 的 implements）。

## 4.6 用例模型（目标系统的逻辑模型）

核心是从角色视角，以用例形式表达软件系统的功能需求，明确目标系统 “做什么”，不涉及 “如何做”。

## 4.7 用例的定义

用例不等于单个功能，而是角色对系统具有目的性的**一系列场景集合**（含成功场景与失败场景），核心在于通过场景完整覆盖用户目标的实现过程。

## 4.8 基本用例与子用例的关系

- 包含关系：多个基本用例的必需步骤抽取为子用例（如 “取款”“查询余额” 均需 “验证身份”，后者为包含子用例），用带 “<>” 的箭头表示。

- 扩展关系：基本用例在特定条件下的可选步骤抽取为子用例（如 “取款” 后 “打印凭据”），用带 “<>” 的箭头表示。

## 4.9 用例说明与 SSD

- 用例说明：以标准化模板描述用例的成功场景、扩展场景、前置条件、后置条件等核心信息。

- SSD（系统顺序图）：用 UML 交互图可视化用例说明，可展示成功场景的交互细节，也可通过片段表示分支场景，是用例文字说明的补充。

## 4.10 SSD 的基本结构

- 核心元素：两个对象（角色对象、待构建的软件系统对象）。

- 交互方式：通过 “消息” 表示角色对系统的请求，及系统的返回结果。

- 消息要求：以可编程的函数名命名（后期作为软件对象方法），包含完整请求参数；返回结果可为具体参数或处理状态。

- 消息类型：支持同步、异步、创建、删除，作业中优先使用同步消息。

## 4.11 操作契约

- 核心内容：描述系统处理请求时，领域模型中对象的状态变化，包括对象的创建 / 删除、关联的建立 / 消除、属性值的修改 / 持久化。

- 关键区别：后置条件是系统内部对象的状态变更，不等于 SSD 中消息的返回结果（返回结果是角色可见的外部反馈）。

## 4.12 操作契约的作用

为后期软件设计提供核心参考，明确软件后台服务器必须具备的软件对象类型，确保系统设计贴合业务逻辑。

### 总结

以上内容是面向对象需求分析的核心能力与规范化方法，通过 UML 建模形成的领域模型、用例模型等，是软件需求规格说明书的主要组成部分，直接指导后续设计与开发。
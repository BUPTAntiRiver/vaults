# Task 2
## 哪一行？
首先我们 `g++ print.cpp -g -o print` 得到可以调试的文件，然后 `gdb ./print`，设置断点 `break print.cpp:27` `run` 目前一切正常，`step` 程序崩溃，所以问题出现在第 27 行代码。
## 为什么崩溃
首先我们来看看**基础知识引导**，我们经过实验发现，在申请 32B 的空间时，事实上会分配 48B 的空间，这说明我们的机器的 meta data 大小应该为 16B，同时在 clue c 中发现，调用 `cout` 之后，地址的差变成了 1088，说明 `cout` 需要使用 1040B 大小的空间，在 clue d 中，我们更加发现再次调用 `cout` 之后对于内存地址没有影响，说明 `cout` 经过一次调用之后会复用之前的 `buffer`。
由此我们可以推断为什么会崩溃，因为我们在 `double_array` 中只显式声明了 8 个数组指针，也就是 32B，但实际上我们访问了 `array_number` 个数组，也就是 64 个，所以我们数组二维数组占用的空间超出了系统知道的范围，这是 undefined behavior，因此在我们调用 `cout` 的时候他以为从 48B 开始就可以了，但其实和我们已经使用的空间覆盖，导致崩溃。所以我们可以将 `array_number` 设置的小一点或者改成 `new int*[n]` 都可以解决问题。
```bash
# Before executing line 27:
(gdb) x/64xg result
0x55555556f2b0: 0x0000555555558160      0x0000555555558260
0x55555556f2c0: 0x0000555555558360      0x0000555555558460
0x55555556f2d0: 0x0000555555558560      0x0000555555558660
0x55555556f2e0: 0x0000555555558760      0x0000555555558860
0x55555556f2f0: 0x0000555555558960      0x0000555555558a60
0x55555556f300: 0x0000555555558b60      0x0000555555558c60
0x55555556f310: 0x0000555555558d60      0x0000555555558e60
0x55555556f320: 0x0000555555558f60      0x0000555555559060
0x55555556f330: 0x0000555555559160      0x0000555555559260
0x55555556f340: 0x0000555555559360      0x0000555555559460
0x55555556f350: 0x0000555555559560      0x0000555555559660
0x55555556f360: 0x0000555555559760      0x0000555555559860
0x55555556f370: 0x0000555555559960      0x0000555555559a60
0x55555556f380: 0x0000555555559b60      0x0000555555559c60
0x55555556f390: 0x0000555555559d60      0x0000555555559e60
0x55555556f3a0: 0x0000555555559f60      0x000055555555a060
0x55555556f3b0: 0x000055555555a160      0x000055555555a260
0x55555556f3c0: 0x000055555555a360      0x000055555555a460
0x55555556f3d0: 0x000055555555a560      0x000055555555a660
0x55555556f3e0: 0x000055555555a760      0x000055555555a860
0x55555556f3f0: 0x000055555555a960      0x000055555555aa60
0x55555556f400: 0x000055555555ab60      0x000055555555ac60
0x55555556f410: 0x000055555555ad60      0x000055555555ae60
0x55555556f420: 0x000055555555af60      0x000055555555b060
0x55555556f430: 0x000055555555b160      0x000055555555b260
0x55555556f440: 0x000055555555b360      0x000055555555b460
0x55555556f450: 0x000055555555b560      0x000055555555b660
0x55555556f460: 0x000055555555b760      0x000055555555b860
0x55555556f470: 0x000055555555b960      0x000055555555ba60
0x55555556f480: 0x000055555555bb60      0x000055555555bc60
0x55555556f490: 0x000055555555bd60      0x000055555555be60
0x55555556f4a0: 0x000055555555bf60      0x000055555555c060
# After executing line 27 with array_number=8
(gdb) x/64xg result
0x55555556b2b0: 0x0000555555558160      0x0000555555558180
0x55555556b2c0: 0x00005555555581a0      0x00005555555581c0
0x55555556b2d0: 0x00005555555581e0      0x0000555555558200
0x55555556b2e0: 0x0000555555558220      0x0000555555558240
0x55555556b2f0: 0x0000000000000000      0x0000000000000411
0x55555556b300: 0x646120746e697270      0x666f207373657264
0x55555556b310: 0x5b746c7573657220      0x3535357830205d30
0x55555556b320: 0x3631383535353535      0x0000000000000a30
0x55555556b330: 0x0000000000000000      0x0000000000000000
0x55555556b340: 0x0000000000000000      0x0000000000000000
0x55555556b350: 0x0000000000000000      0x0000000000000000
0x55555556b360: 0x0000000000000000      0x0000000000000000
0x55555556b370: 0x0000000000000000      0x0000000000000000
0x55555556b380: 0x0000000000000000      0x0000000000000000
0x55555556b390: 0x0000000000000000      0x0000000000000000
0x55555556b3a0: 0x0000000000000000      0x0000000000000000
0x55555556b3b0: 0x0000000000000000      0x0000000000000000
0x55555556b3c0: 0x0000000000000000      0x0000000000000000
0x55555556b3d0: 0x0000000000000000      0x0000000000000000
0x55555556b3e0: 0x0000000000000000      0x0000000000000000
0x55555556b3f0: 0x0000000000000000      0x0000000000000000
0x55555556b400: 0x0000000000000000      0x0000000000000000
0x55555556b410: 0x0000000000000000      0x0000000000000000
0x55555556b420: 0x0000000000000000      0x0000000000000000
0x55555556b430: 0x0000000000000000      0x0000000000000000
0x55555556b440: 0x0000000000000000      0x0000000000000000
0x55555556b450: 0x0000000000000000      0x0000000000000000
0x55555556b460: 0x0000000000000000      0x0000000000000000
0x55555556b470: 0x0000000000000000      0x0000000000000000
0x55555556b480: 0x0000000000000000      0x0000000000000000
0x55555556b490: 0x0000000000000000      0x0000000000000000
0x55555556b4a0: 0x0000000000000000      0x0000000000000000
```
这表明 `cout` 从第十个地址开始使用 heap，我在测试的时候也发现当修改 `array_number` 为 9 的时候可以正常运行，但为 10 的时候就崩溃了。
## 为什么取消注释正常了？
这就是因为先调用 `cout` 改变了 heap 的 data layout，用于 `cout` 的 `buffer` 放在了开头，后面的 undefined behavior 只会去覆盖空白未使用的区域，所以能够正常运行。
# Task 3
运行过程中会有输出，但不可以正常运行。在 30 行崩溃。
```
print content of result[7][63] 63
print address of result[8] 0
make: *** [Makefile:25: print_v2] Segmentation fault (core dumped)
```
为什么变得可以正常运行了呢？或许这正如在 task 2 中所尝试的那样，只要第 10 个地址空间，从 offset 上来说就是 9 不被使用，那么 `cout` 就能正常运行，然后当我们访问 `i=8` 时候，因为我们跳过了这个数组，所以其存储所有地址都是 0，所以我们回去访问地址为 0 的空间，然而这是未定义行为，这块空间并未被使用所以就崩溃了。
当我尝试把 `i=8` 跳过去掉后，发现果然也是能正常运行的，但是同样会在 `i=9` 的情况下崩溃：
```
print content of result[8][63] 63
print address of result[9] 0x411
make: *** [Makefile:25: print_v2] Segmentation fault (core dumped)
```
因为这个地址同样是没有被声明使用的。
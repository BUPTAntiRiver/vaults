# Lecture 1
众所周知，第一节课什么都不教。
# Lecture 2 Boot, Process, Kernel
## Booting
BIOS -> bootloader -> kernel
## Process
### Process in Memory
Stack: 临时变量
Heap: 全局变量
## Kernel
### Limited Direct Execution
OS needs to check the instructions to be executed, in order to prevent detrimental behavior.
"Sensitive" instructions go through OS, most instructions run directly on CPU, which ensures good performance and good isolation.
The following instructions are limited:
1. Restricted operations (特权指令)
2. inter-process switching: voluntary and involuntary switching like timer interrupt (时钟中断)
### Dual Mode
User mode (用户态) and kernel mode (内核态) 这两者都是 CPU 的状态，由 OS 控制。
The status is stored in `cs` register, 0 for kernel mode, 3 for user mode (use only 2 bits).
### Privileged Instructions (特权指令)
I/O read/write, context switch, changing privilege level, set system time... Any instructions that *could affect other processes* are likely to be privileged.
# Lecture 3 Context Switch
## User to Kernel Mode Switch
### E, I, S
**Exceptions (异常)**
When processor encounter *unexpected* condition.
e.g. divide-by-zero, perform privileged instructions, etc.
**Interrupts (中断)**
*Asynchronous* (异步) signal to the processor that some *external* event has occurred.
**System calls (系统调用，trap)**
User processes *request* the kernel to do some operations.
### Interrupt Vector Table (中断向量表)
It stores the entries of different handlers for exceptions, interrupts and traps (all of three, the name is confusing). There is a register pointing to the vector table which is stored in kernel memory, and each element in the vector points to handler.
Nowadays we have something like Interrupt Descriptor Table (IDT, 中断描述符表), which tells CPU where the Interrupt Service Routines (ISR, 中断服务程序) are located.
*Entries* are called "**Gates**" (the gate that separates user and kernel), its location is kept in **IDTR** (IDT register) and is loaded with **LIDT** assembly instruction.
### Interrupt Masking (中断屏蔽)
### Interrupt Stack (中断栈)
## Kernel to User Mode Switch
SKIP
## x86 example
### x86 background
Program counter: `cs` register and `eip` register.
# Lecture 4 OS Interfaces and Syscalls
## `fork()`
Create a complete copy of the parent process, except the returning value: 0 for *child*, pid of child for *parent*.
## `exec()`
Load and execute a process from disk, it does not create new process.
## Aside
Difference between `Ctrl-C` and `Ctrl-Z`.
`Ctrl-C` sends a `SIGINT` (interrupt) to the process, while `Ctrl-Z` sends a `SIGTSTP` (stop) signal that pauses the process in mid-execution.
# Lecture 5 Threads

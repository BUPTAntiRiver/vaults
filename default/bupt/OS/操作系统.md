# Lecture 1
众所周知，第一节课什么都不教。
# Lecture 2 Boot, Process, Kernel
## Booting
BIOS -> bootloader -> kernel
## Process
### Process in Memory
Stack: 临时变量
Heap: 全局变量
## Kernel
### Limited Direct Execution
OS needs to check the instructions to be executed, in order to prevent detrimental behavior.
"Sensitive" instructions go through OS, most instructions run directly on CPU, which ensures good performance and good isolation.
The following instructions are limited:
1. Restricted operations (特权指令)
2. inter-process switching: voluntary and involuntary switching like timer interrupt (时钟中断)
### Dual Mode
User mode (用户态) and kernel mode (内核态) 这两者都是 CPU 的状态，由 OS 控制。
The status is stored in `cs` register, 0 for kernel mode, 3 for user mode (use only 2 bits).
### Privileged Instructions (特权指令)
I/O read/write, context switch, changing privilege level, set system time... Any instructions that *could affect other processes* are likely to be privileged.
# Lecture 3 Context Switch
## User to Kernel Mode Switch
### E, I, S
**Exceptions (异常)**
When processor encounter *unexpected* condition.
e.g. divide-by-zero, perform privileged instructions, etc.
**Interrupts (中断)**
*Asynchronous* (异步) signal to the processor that some *external* event has occurred.
**System calls (系统调用，trap)**
User processes *request* the kernel to do some operations.
### Interrupt Vector Table (中断向量表)
It stores the entries of different handlers for exceptions, interrupts and traps (all of three, the name is confusing). There is a register pointing to the vector table which is stored in kernel memory, and each element in the vector points to handler.
Nowadays we have something like Interrupt Descriptor Table (IDT, 中断描述符表), which tells CPU where the Interrupt Service Routines (ISR, 中断服务程序) are located.
*Entries* are called "**Gates**" (the gate that separates user and kernel), its location is kept in **IDTR** (IDT register) and is loaded with **LIDT** assembly instruction.
### Interrupt Masking (中断屏蔽)
### Interrupt Stack (中断栈)
## Kernel to User Mode Switch
SKIP
## x86 example
### x86 background
Program counter: `cs` register and `eip` register.
# Lecture 4 OS Interfaces and Syscalls
## `fork()`
Create a complete copy of the parent process, except the returning value: 0 for *child*, pid of child for *parent*.
## `exec()`
Load and execute a process from disk, it does not create new process.
## Aside
Difference between `Ctrl-C` and `Ctrl-Z`.
`Ctrl-C` sends a `SIGINT` (interrupt) to the process, while `Ctrl-Z` sends a `SIGTSTP` (stop) signal that pauses the process in mid-execution.
# Lecture 5 Threads
# Lecture 12 Readers/Writers and Deadlock
## Readers/Writers Lock
The motivation is suppose we have a database, and there are two kinds of operations: **read**, which never modify database and **write**, which read and modify database. Is using a single lock on the whole database a good idea? It is correct but not efficient. Because we can have many readers working at the same time, but for writers, only one can work at a time.
## Deadlock
### Four requirements for Deadlock
- Mutual exclusion
	- Only one thread at a time can use a resource.
- Hold and Wait
	- Thread holding at least one resource is waiting to acquire additional resources held by other threads.
- No preemption
	- Resources are released only voluntarily by the thread holding the resource, after thread is finished with it.
- Circular wait
	- There exist a set of waiting threads each waits the one after it.
### Preventing Deadlocks
1. No circular wait: careful design.
2. No hold-and-wait: use another lock to lock the locks, which may decrease concurrency.
3. No mutual exclusion: this may be very complicated, and need hardware support.
4. Smart scheduling: banking algorithm
### Banking Algorithm
Usually the request and assignment of resources are not determined at a single point, which means resources are taken/released over time. So we can't know order/amount of requests ahead of time, we can only assume some worst-case "max" resource needed by each process.
So we should state maximum resource needed in advance;
Only allow particular thread to proceed if available resources is greater than requested plus max remaining need resource.
# 第一章

语言的表示方法:

1. 集合表示法
2. 文法
3. 正则表达式
4. 自动机

## 字母表

### 定义 1-1: **字母表**

- 字母表是一个非空有穷集合, 字母表中的元素称为该字母表的一个**字母**, 又叫做符号, 或者字符.

### 定义 1-2: 字母表的**乘积**

$$\Sigma_1\Sigma_2=\{ab|a\in\Sigma_1,b\in\Sigma_2\}$$

- 字母表乘积不具有交换性

### 定义 1-3: 字母表$\Sigma$的$n$**次幂**

$\Sigma^0=\{\epsilon\}$
$\Sigma^n=\Sigma^{n-1}\Sigma,n\geq1$
$\epsilon$是由$\Sigma$中的 0 个字符组成的**空串**.

正闭包与克林闭包的区别在于, 正闭包不包含空串.

真前缀与前缀的区别在于前缀包含句子自身, 而真前缀不包含. 真后缀与后缀同理.

## 语言

### 定义 1-14: 语言

$\forall L\subseteq \Sigma^*$ , $L$称为字母表$\Sigma$上的一个**语言**, $\forall x\in L$, $x$叫做$L$的一个句子.

# 第 7 章 下推自动机 PDA

## PDA 与 CFG 等价

### 终态接受与空栈接受相等价

#### 终态 to 空栈

添加一个状态，当达到终态后，完成**清栈**工作。
添加一个状态和一个**栈底元素**，防止自动机在识别过程中达到空栈，使得本来应该被拒绝的串因为空栈而被错误接受。

#### 空栈 to 终态

为了使得新 PDA 能够模拟达到空栈的效果，添加一个**栈底元素**，和一个开始状态。
添加一个终止状态，当栈底元素称为栈顶时，进入。

### PDA 等价于 CFG

**预处理**：将 CFG 化简为 GNF 然后再构造 PDA

#### CFG to PDA

对于任意的 $A\in V,a\in T,\gamma \in V^*:$
$\delta(q,a,A)=\{(q,\gamma)|A\rightarrow a\gamma \in P\}$
GNF 不考虑空串情况，最后我们单独考虑空串，添加一个起始状态 $q_0$ 和栈底元素 $Z$ 如果遇到空串直接接受，或者视作空移动移至 $q$ 继续接受。

#### PDA to CFG

将 $[q, A, ?]$ 视作 CFG 中的一个**变量**，此处使用的符号是 PDA 中的符号，$q$ 表示**当前状态**符号，$A$ 表示相应的**栈顶符号**，$?$ 表示当前的**次栈顶**（$A$ 下方一项）成为栈顶时的**状态符号**。
例如：对于 PDA 的移动 $\delta(q,a,A)=(q_1,A_1A_2\ldots A_n)$ 可以表示为
$$[q,A,?]\rightarrow a[q_1,A_1,q_2][q_2,A_2,q_3]\ldots[q_n,A_n,?]$$
此处 $?$ 可能是任意状态，因此在构造时需要考虑全部状态，这就使得一个 PDA 移动可以转换成 $|Q|^n$ 个 CFG 产生式。
可以通过画出状态转移图来判断哪些产生式是不可能的，可以消去化简。

# 第 8 章 上下文无关文法的性质

## CFL 的泵引理

正则语言存在泵引理来证明一个语言不是正则语言，对于 CFL 而言，也有泵引理。

### 定义：CFL 的泵引理

对于任意的 CFL $L$，存在仅依赖于 $L$ 的正整数 $N$，对于**任意**的 $z\in L$，当 $|z|\geq N$ 时，**存在** $u,v,w,x,y$，使得 $z=uvwxy$，同时满足：

1. $|vwx|\leq N$
2. $|vx|\geq 1$
3. 对于任意的非负整数 $i$，$uv^iwx^iy\in L$

### 证明不是 CFL 步骤

1. 首先假设该语言是 CFL，则其应满足泵引理，选取**任意**的 N
2. 找到某一个语言中的句子 $z\in L(|z|\geq N)$
3. **分析各种 $v,x$ 取值**，当满足 $z=uvwxy$，且 $|vwx|\leq N,|vx|\geq 1$ 时，均能找到一个 $i\geq 0$，使得 $uv^i wx^i y\notin L$，对于任意 $v,x$ 取法都如此才能证明，因为在泵引理中是存在
4. 出现矛盾，假设不成立

## Ogden 引理（不考）

## CFL 封闭性

- CFL 在并、乘、闭包、代换、同态映射、逆同态映射等运算下是封闭的。
- CFL 与 **RL** 的交运算是 CFL。
- **CFL 在交、补运算下是不封闭**。

## CFL 相关判定算法

- 存在判定 CFG 产生的语言**是否为空、是否有穷、是否无穷**，以及一个给定的符号串 x 是否为该文法产生的语言的一个句子的算法(CYK 算法)。

### 判定 CFL 非空

化简原 CFG，删去派生不出终极符号行的变量，如果开始符号在化简后的 CFG 中，那么非空。

### 判定 CFL 有穷

画出**可派生性图**，一种只包含变量符号作为顶点的有向图，边表示某变量能够产生出另一变量。
如果可派生性图中**存在有向回路**，且该回路中的顶点是**开始符号可达**的，那么就是无穷语言，否则有穷。

### CFL 成员判定（CYK 算法）

基本思想：设给定的文法为 **CNF** 文法，对于任意字符串 x，如果 x 的第 k 个字符 a 可以由 B 派生出，并且 x 的第 k+1 个字符 b 可以由 C 派生出，当 A->BC∈P 时，ab 可以由 A 派生出。
更一般地，我们来讨论子串，设 $x_{i,k}$ 表示字符串 $x$ 从第 $i$ 个字符开始长度为 $k$ 的子串。上述基本思想就是子串为一个字符的特殊情况，一般情况下上述推导也成立。

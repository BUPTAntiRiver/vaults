# 第 1 章

语言的表示方法:

1. 集合表示法
2. 文法
3. 正则表达式
4. 自动机

## 字母表

### 定义 1-1: **字母表**

- 字母表是一个非空有穷集合, 字母表中的元素称为该字母表的一个**字母**, 又叫做符号, 或者字符.

### 定义 1-2: 字母表的**乘积**

$$\Sigma_1\Sigma_2=\{ab|a\in\Sigma_1,b\in\Sigma_2\}$$

- 字母表乘积不具有交换性

### 定义 1-3: 字母表$\Sigma$的$n$**次幂**

$\Sigma^0=\{\epsilon\}$
$\Sigma^n=\Sigma^{n-1}\Sigma,n\geq1$
$\epsilon$是由$\Sigma$中的 0 个字符组成的**空串**.
正闭包与克林闭包的区别在于, 正闭包不包含空串.
真前缀与前缀的区别在于前缀包含句子自身, 而真前缀不包含. 真后缀与后缀同理.

## 语言

### 定义 1-14: 语言

$\forall L\subseteq \Sigma^*$ , $L$称为字母表$\Sigma$上的一个**语言**, $\forall x\in L$, $x$叫做$L$的一个句子.

# 第 2 章 文法

关于文法的定义经过后续的练习已经较为熟练，不再赘述。记录一些需要记忆的概念。

## 乔姆斯基文法体系

以下所有产生式要求，不考虑空产生式。

### 0 型

任意文法，无约束条件。

### 1 型 （上下文有关文法）

0 型文法，且满足 $\forall \alpha\rightarrow \beta\in P$，均有 $|\beta|\geq|\alpha|$ 成立。

### 2 型 （上下文无关文法）

1 型文法，且满足 $\forall \alpha\rightarrow \beta\in P$，均有 $|\beta|\geq|\alpha|$，并且 $\alpha\in V$ 成立。

### 3 型 （正则文法）

2 型文法，且满足 $\forall \alpha\rightarrow \beta\in P$，均有 $A\rightarrow w$ 或者 $A\rightarrow wB$ 其中 $A,B$ 为变量，$w$ 为终极符号串。

## 线性文法，线性语言

产生式形如 $A\rightarrow w$ 或者 $A\rightarrow wBx$ 其中 $A,B$ 为变量，$w$ 为终极符号串。类似于左右开弓的正则文法。

### 右线性

去掉右边的 $x$，就是正则文法。

### 左线性

去掉左边的 $w$，*等价*于右线性文法。**右线性**文法自然地对应句子的**推导**过程，**左线性**文法自然地对应句子的**归约**过程。

## 空语句

只有在开始符号**不出现在产生式的右侧**时，存在开始符号的空产生式对文法的类型没有影响。
对于其他变量，是否存在空产生式对于文法类型没有影响。

# 第 3 章 有穷状态自动机

用来识别句子是否属于该语言，常规的算法效率较低，提出自动机。

## DFA

D 表示 deterministic，一个自动机每一步转移都是确定的，每个状态对于每个输入有且仅有一个可以达到的状态。
如果两个 FA 接受的语言等价（接受的句子的集合），那么这两个 FA 等价。

## NFA

转移图中，边上的输入可以重复。

### NFA 与 DFA 等价

NFA 可以在同一时刻进入多种状态，但我们可以用 DFA 中的一个状态来对应多种状态的**一组状态**。

## 带空移动的 NFA

引入空移动让我们打造更加简洁直观的 NFA。

### 空闭包

$\epsilon -\text{CLOSURE}$ 表示从状态 q 出发，所有经由 $\epsilon$ 路径能到达的状态 $p$ 的集合。

### 转换为 NFA

**扩展转移函数**：把每个状态用他的空闭包替换，然后把它能到达的状态用空闭包能到达的状态替换。
将扩展转移函数的结果中的空闭包视为新状态，构造 NFA 即可。

## FA 与正则文法等价

FA 接受的语言是正则语言。
左线性 $\iff$ 右线性 $\iff$ 正则 $\iff$ FA

# 第 4 章 正则表达式

正则表达式是另一种 **NFA 相关**的语言定义表示方法，便于我们更加直观地理解。

## 形式定义

$r+s$ 表示 $R\cup S$，$rs$ 表示 $RS$，$r^*$ 表示克林闭包。计算优先级为闭包大于乘法大于加法。

## RE 与 FA 转化

RE 转 FA 比较简单，主要讲 FA 转 RE。

### 图上作业法

1. 添加 X 与 Y 状态，用空移动链接开始和终止状态。去掉所有不可达状态。
2. 并弧，用加法并弧。
3. 去状态，如果可以直接去除，用乘法连接，如果存在指向自己的转移，用闭包表示再进行乘法连接。
4. 最后 X 直接到 Y，弧上表达式就是正则表达式。如果不存在这样的弧，那么语言为 $\phi$ 空集。

# 第 5 章 正则语言的性质

## 泵引理

设 $L$ 是一个 Regular Language，则*存在仅依赖于 $L$ 的正整数 $N$*，对于 $\forall z \in L$，如果 $|z|\geq N$，则*存在 $u,v,w$*，满足：

1. $z=uvw$
2. $|uv|\leq N$
3. $|v|\geq 1$
4. 对于任意的整数 $i\geq 0$，$uv^iw\in L$
5. $N$ 不大于接受 $L$ 的最小 DFA 的状态数

泵引理是一个语言是 RL 的必要条件而不是充分条件，故泵引理无法证明一个语言是 RL 但是可以证明一个语言不是 RL（反证法）。

## 正则语言的封闭性

正则语言在以下运算中具有封闭性：
并、交、补、连接、闭包、正则代换、同态、逆同态、商。
正则代换将一个字母映射成一个语言，同态，逆同态是正则代换的特例。

## DFA 极小化

### 分割法

1. 去除不可达状态
2. 按照 终态/非终态 将状态分割为两类
3. 不断循环分割子集，如果某状态对于不同输入的移动进入的状态子集与其他状态就需要进行分割
4. 不能继续分割时停止

### 填表法

首先我们建立一个可区分状态表用来标记两个状态之间是否可以区分。
先根据终态非终态进行初步的标记。
然后对于每一对状态，观察其在所有输入下的结果，$(p\prime,q\prime)$ 如果该状态对被标记，那么标记原来状态对，如果没被标记，加入原状态的等价链表中，他们一荣俱荣一损俱损，在后面如果有谁被标记了大家一起标记。
遍历完成后，将所有未标记的状态对进行合并。

# 第 6 章 上下文无关语言

我们发现有些上下文无关语言存在*二义性*。开始符号经过不同的过程推导出相同的句子。

## CFG 的化简

### 无用符号

语言中存在无用符号，满足以下条件的才是*有用符号*：

1. 推导出终极符号
2. 可被派生出来

实际过程中，我们会：

1. 删除派生不出终极符号行的变量
2. 删除不出现在任何句型中的语法符号（包括变量和终极符）
   一定要按照顺序使用，调换顺序可能会导致化简不彻底。

### 空产生式

我们还需要处理*空产生式*，空产生式会让推导变得复杂。
给所有产生式额外添加一个将存在空产生的状态替换为空的产生式，然后就可以去掉空产生式，二者的效果等价。

### 单一产生式

用对应状态的右部来代替。

## CNF 乔姆斯基范式

产生式满足形式：
$A\rightarrow BC,A\rightarrow a$
不允许有空产生式，单一产生式。

## GNF 格雷巴赫范式

产生式形如：
$A\rightarrow a,A\rightarrow aA_1A_2\ldots A_m$
难点在于，如何解决形如 $A\rightarrow A\alpha$ 的产生式？
将直接左递归转换为*右递归*。
例如：

$$
\begin{aligned}
&\begin{cases}
A\rightarrow \beta_1|\beta_2|\ldots|\beta_m\\
A\rightarrow A\alpha_1|A\alpha_2|\ldots|A\alpha_n
\end{cases}\\
&可以被等价地替换为产生式组\\
&\begin{cases}
A\rightarrow \beta_1|\beta_2|\ldots|\beta_m\\
A\rightarrow \beta_1B|\beta_2B|\ldots|\beta_mB\\
B\rightarrow\alpha_1|\alpha_2|\ldots|\alpha_n\\
B\rightarrow \alpha_1B|\alpha_2B|\ldots|\alpha_nB\\
\end{cases}
\end{aligned}
$$

# 第 7 章 下推自动机 PDA

## PDA 与 CFG 等价

### 终态接受与空栈接受相等价

#### 终态 to 空栈

添加一个状态，当达到终态后，完成**清栈**工作。
添加一个状态和一个**栈底元素**，防止自动机在识别过程中达到空栈，使得本来应该被拒绝的串因为空栈而被错误接受。

#### 空栈 to 终态

为了使得新 PDA 能够模拟达到空栈的效果，添加一个**栈底元素**，和一个开始状态。
添加一个终止状态，当栈底元素称为栈顶时，进入。

### PDA 等价于 CFG

**预处理**：将 CFG 化简为 GNF 然后再构造 PDA

#### CFG to PDA

对于任意的 $A\in V,a\in T,\gamma \in V^*:$
$\delta(q,a,A)=\{(q,\gamma)|A\rightarrow a\gamma \in P\}$
GNF 不考虑空串情况，最后我们单独考虑空串，添加一个起始状态 $q_0$ 和栈底元素 $Z$ 如果遇到空串直接接受，或者视作空移动移至 $q$ 继续接受。

#### PDA to CFG

将 $[q, A, ?]$ 视作 CFG 中的一个**变量**，此处使用的符号是 PDA 中的符号，$q$ 表示**当前状态**符号，$A$ 表示相应的**栈顶符号**，$?$ 表示当前的**次栈顶**（$A$ 下方一项）成为栈顶时的**状态符号**。
例如：对于 PDA 的移动 $\delta(q,a,A)=(q_1,A_1A_2\ldots A_n)$ 可以表示为
$$[q,A,?]\rightarrow a[q_1,A_1,q_2][q_2,A_2,q_3]\ldots[q_n,A_n,?]$$
此处 $?$ 可能是任意状态，因此在构造时需要考虑全部状态，这就使得一个 PDA 移动可以转换成 $|Q|^n$ 个 CFG 产生式。
可以通过画出状态转移图来判断哪些产生式是不可能的，可以消去化简。

# 第 8 章 上下文无关文法的性质

## CFL 的泵引理

正则语言存在泵引理来证明一个语言不是正则语言，对于 CFL 而言，也有泵引理。

### 定义：CFL 的泵引理

对于任意的 CFL $L$，存在仅依赖于 $L$ 的正整数 $N$，对于**任意**的 $z\in L$，当 $|z|\geq N$ 时，**存在** $u,v,w,x,y$，使得 $z=uvwxy$，同时满足：

1. $|vwx|\leq N$
2. $|vx|\geq 1$
3. 对于任意的非负整数 $i$，$uv^iwx^iy\in L$

### 证明不是 CFL 步骤

1. 首先假设该语言是 CFL，则其应满足泵引理，选取**任意**的 N
2. 找到某一个语言中的句子 $z\in L(|z|\geq N)$
3. **分析各种 $v,x$ 取值**，当满足 $z=uvwxy$，且 $|vwx|\leq N,|vx|\geq 1$ 时，均能找到一个 $i\geq 0$，使得 $uv^i wx^i y\notin L$，对于任意 $v,x$ 取法都如此才能证明，因为在泵引理中是存在
4. 出现矛盾，假设不成立

## Ogden 引理（不考）

## CFL 封闭性

- CFL 在并、乘、闭包、代换、同态映射、逆同态映射等运算下是封闭的。
- CFL 与 **RL** 的交运算是 CFL。
- **CFL 在交、补运算下是不封闭**。

## CFL 相关判定算法

- 存在判定 CFG 产生的语言**是否为空、是否有穷、是否无穷**，以及一个给定的符号串 x 是否为该文法产生的语言的一个句子的算法(CYK 算法)。

### 判定 CFL 非空

化简原 CFG，删去派生不出终极符号行的变量，如果开始符号在化简后的 CFG 中，那么非空。

### 判定 CFL 有穷

画出**可派生性图**，一种只包含变量符号作为顶点的有向图，边表示某变量能够产生出另一变量。
如果可派生性图中**存在有向回路**，且该回路中的顶点是**开始符号可达**的，那么就是无穷语言，否则有穷。

### CFL 成员判定（CYK 算法）

基本思想：设给定的文法为 **CNF** 文法，对于任意字符串 x，如果 x 的第 k 个字符 a 可以由 B 派生出，并且 x 的第 k+1 个字符 b 可以由 C 派生出，当 A->BC∈P 时，ab 可以由 A 派生出。
更一般地，我们来讨论子串，设 $x_{i,k}$ 表示字符串 $x$ 从第 $i$ 个字符开始长度为 $k$ 的子串。上述基本思想就是子串为一个字符的特殊情况，一般情况下上述推导也成立。
看道例题就全明白了。

# 第 9 章 图灵机

图灵机的基本结构包括一个有穷控制器，一个*含有无穷多带方格*的输入带，一个*读写*头。
图灵机符号表示为：$\text{TM}\ M=(Q,\Sigma,\Gamma,\delta,q_0,B,F)$
其中 $\Gamma,B$ 是新东西，他们分别表示*输入带符号表*和*空白符*。
图灵机的转移函数也有所不同：$\delta(q,X)=(p,Y,R/L)$ 表示 M 在状态 q 读入符号 X，将状态改为 p，并且在当前格印刷 Y，然后左移或者右移。

# 第 10 章 上下文有关语言

最后我们来讨论 0 型语言和 1 型语言。
0 型语言等价于 TM，图灵机。
1 型语言等价于线性有界自动机，即方格带有左右边界的图灵机。

# 一些回顾

**x86-64 寄存器约定**

- 参数传递： `%rdi, %rsi, %rdx, %rcx, %r8, %r9`
- 返回值： `%rax`
- Callee-saved 被调用侧存储： `%rbx, %r12, %r13, %r14, %rbp, %rsp`
- Caller-saved 调用侧存储： `%rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11`
- Stack pointer 栈指针： `%rsp`
- Instruction pointer 指令指针： `%rip`

**x86-64 Stack 栈**

栈朝着**更低**的内存地址方向**向下**增长。
`%rsp` 指向栈的**顶部**，地址最小处。
`push %reg` 使 `%rsp` 减去 8，然后将 `%reg` 中的值存储在 `(%rsp)`。
`pop %reg` 将 `(%rsp)` 中的值存至 `%reg`，然后使 `%rsp` 增加 8。

**x86-64 Stack Frames 帧栈**

每一个函数调用都有它自己的**帧栈**。
可以把帧看作每个函数的工作空间：

- 局部变量
- Callee 和 Caller-saved 寄存器
- 函数调用的可选参数

# Attack Lab 总览

## Phases 1-3

**Overview**

- Exploit x86-64 by overwriting the stack
- Overflow a buffer, overwrite return address
- Execute injected code

**建议**

- 使用 `objdump -d` 来确定相应的偏移量
- 使用 `gdb` 来确定栈地址

## Phases 4-5

**Overview**

- 利用面向返回编程来执行任意代码
- 通过在一小段代码末尾添加 `c3` 代表 `ret` 来实现注入代码

**建议**

- 使用 `pop` 和 `mov` 指令以及常量来实现各种功能

# 开始做！

做之前我们先把 write up 文档看一遍。
因为我们没有使用 shark machine 所以在`run`的时候需要使用`run -q`

## Phase 1

在阶段 1 中我们不需要注入新的代码，只需要覆盖返回地址从而运行我们想要执行的代码 `touch1` 即可。已知我们 `getbuf` 函数接受一段字符串，我们只需要输入一个足够长的字符串直到溢出，然后将溢出的部分设置为我们想要跳转到的地址。这是由 `ret` 工作的原理决定的。`ret` 弹出栈顶元素作为下一个执行代码的地址。
那么问题就很清楚了，我们需要处理两件事：

1. `getbuf` 栈长度有多长？我们输入多长的字符串能够溢出。
   我们在 `getbuf` 设置断点然后 `disas` 就能发现分配长度。
2. 我们需要跳转的地址是什么？
   跳转的地址通过查看 `objdump` 得到结果中 `touch1` 相应地址即可。

最后编辑好我们的输入字符串，一大堆意义不明的字符再加上我们的地址即可。

## Phase 2

阶段 2 相比 1 多了一步，需要我们给函数传递参数，这就需要我们执行额外的代码来修改存储变量的寄存器，同时在运行完这段代码后还要重新跳转回 `touch2` 那么我们就遇到了两个新问题：

1. 怎么添加额外的代码呢？
   还记得我们输入的一大堆意义不明的符号的字符串么？现在我们要赋予它们意义了！我们先手动编写修改寄存器值的代码 `movq <Cookie>, %rdi` 然后对其进行编译，再将得到的十六进制代码移动到我们的字符串中，就大功告成了！但问题是，我们原来溢出后跳转的位置是 `touch1` 现在我们要把他改成我们这段代码的位置，可以通过观察 `rsp` 的值来计算。
2. 怎么执行完代码再跳转到 `touch2`呢？
   还记得 `ret` 的原理吗？弹出栈顶值，作为地址进行跳转，我们只需要再 `push` 一下 `torch2` 的地址再 `ret` 即可。

将上述修改结合起来，我们就完成阶段 2 了。

## Phase 3

阶段 3 更加复杂一点，我们需要把一个指针作为变量进行传递，这看起来很简单，但它其实隐含着另一项任务：维护我们指针所指向的目标，在此处为一个字符串。我们要在什么地方存储这个字符串呢？我们所能掌握的内存区域，也就是输入字符串时的这段栈区域了，此外它还不能被其他代码所干扰，因此我们需要在 `touch3` 中的 `hexmatch` 前后添加断点，观察执行该函数前后对栈区域的破坏，从中找到一段安全的区域然后将字符串存储在这里。其余的操作细节与前面的阶段相同。
在检查栈区域变化时，可以用：`x/80x <stack address>` 来进行观察。

## Phase 4

为了复刻阶段 2 的任务，我们需要先将 Cookie 的值存到寄存器 `rdi` 里，然后再跳转到 `touch2` 的位置。
为了方便，我们先获取 `farm.c` 的字节文件，可以让 ai 对得到的文件进一步清理，只留下字节代码同时让他们处在同一行。
存 Cookie 需要 `popq` 如果能直接存到 `rdi` 最好了，我们先看看能否做到，正则匹配 `5f c3` 发现没有，那就只能再试试别的寄存器，后面再传给 `rdi`，正则匹配 `5[89a-f] (90 )+c3` 发现两个！都是存到 `rax` 那接下来就找找 `movq %rax, %rdi` 正则匹配 `48 89 c7 c3` 也有！那我们就成功做到把 Cookie 存在 `rdi` 里面了，跳转 `touch2` 只需要我们多写一点地址就行，开始组装！
注意每次读取都是读取 8 个字节，所以我们给每个地址和数据都要补上足够的 0 防止 Segment Error.

## Phase 5

现在来到阶段 5！最后的难题！我们还是一步一步做，我们在阶段 3 需要做些啥来着？
先输入字节溢出，然后开始执行 ROP，我们需要获取 `rsp` 现在每次 `rsp` 都是不同的，所以我们需要获取 `rsp` 到我们溢出数组的偏移量 Offset，这是可以手动计算的，放在那里后面我们 `popq` 出来。
偏移量的计算方法就是，运行到 `pop` 偏移量这行指令时，与我们存储 Cookie 的地址之间的距离就是偏移量了。
然后我们需要将 `rsp` 与 Offset 相加，再将得到的值移动至 `rdi` 大功告成！
第一步先找到 `movq %rsp <any reg>` 的代码，正则匹配 `48 89 e[0-7] c3` 成功找到。
接下来我们找 `popq <reg>` 的代码，来获取我们的偏移量，正则匹配 `5[8-f] (90 )+c3`，结果发现只找到 `pop` 到 `rax` 的，与我们第一步找的重复了，所以我们还需要为了第一步再找一个 `movq` 来转移一下 `rsp` 的值。正则匹配 `48 89 c[0-7] c3` 找到了 `movq %rax, %rdi` 这下问题解决。
再接下来我们需要实现 `rsp` 和偏移量的相加，目前它们分别存储在 `rdi` 和 `rax` 中，现在问题来了，我们怎么计算加法呢？介绍的指令当中明明没有 `add` 呀！但是！我们发现 `farm.c` 里面存在加法！我们只需要调用这个函数就可以计算加法了！但是参数传递这一块，我们需要数据存储在 `rdi` 和 `rsi` 中，所以我们需要把 `rax` 中的偏移量转移到 `rsi` 中。我们发现没有直接的转移方法，于是寻找用其他寄存器作为中转的方法。
最终找到了一条曲折的路，`movl %eax, %edx`，`movl %edx, %ecx`，`movl %ecx, %esi` 总算移到了 `rsi` 中。然后就是调用函数 `add_xy` 现在最终的地址就存储在 `rax` 里面！再把它转移到 `rdi` 中即可！！一共 8 步和答案数量相同！开始组装！！
大功告成！
